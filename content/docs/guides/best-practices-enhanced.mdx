---
title: Best Practices
description: Tips for building robust and efficient integrations
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

# Best Practices

Build robust, efficient, and maintainable integrations with our API.

## Categories

<Cards>
  <Card
    title="Error Handling"
    description="Gracefully handle errors and edge cases"
    href="#error-handling"
  />
  <Card
    title="Performance"
    description="Optimize for speed and efficiency"
    href="#performance-optimization"
  />
  <Card
    title="Security"
    description="Keep your integration secure"
    href="#security"
  />
  <Card
    title="Rate Limiting"
    description="Respect API limits and implement backoff"
    href="#rate-limiting"
  />
</Cards>

## Error Handling

<Callout type="error">
**Always handle errors gracefully.** Network failures, rate limits, and server errors will happen. Your code should handle them without breaking.
</Callout>

### Implement Retry Logic

```javascript title="retry-logic.js"
async function makeRequestWithRetry(url, options, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);

      if (response.ok) {
        return await response.json();
      }

      // Don't retry on client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }

      // Retry on server errors (5xx)
      if (i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      throw new Error(`Request failed after ${maxRetries} retries`);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
    }
  }
}
```

### Handle Specific Error Cases

<Accordions>
  <Accordion title="401 Unauthorized">
**Cause**: Invalid or expired credentials

**Action**:
- Verify API key is correct
- Check if token has expired
- Refresh access token if using OAuth
- Prompt user to re-authenticate

```javascript
if (response.status === 401) {
  const newToken = await refreshAccessToken();
  // Retry request with new token
}
```
  </Accordion>

  <Accordion title="429 Too Many Requests">
**Cause**: Rate limit exceeded

**Action**:
- Check `Retry-After` header
- Implement exponential backoff
- Queue requests for later processing

```javascript
if (response.status === 429) {
  const retryAfter = response.headers.get('Retry-After');
  await sleep(retryAfter * 1000);
  // Retry request
}
```
  </Accordion>

  <Accordion title="500 Internal Server Error">
**Cause**: Server-side issue

**Action**:
- Retry with exponential backoff
- Log error for monitoring
- Alert if persists

```javascript
if (response.status >= 500) {
  logger.error('Server error', { status: response.status });
  // Implement retry logic
}
```
  </Accordion>
</Accordions>

## Performance Optimization

<Callout type="info">
**Performance Tips**: Use pagination, caching, and parallel requests to optimize your integration.
</Callout>

### Use Pagination

```javascript title="pagination.js"
async function fetchAllUsers() {
  const users = [];
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    const response = await fetch(
      `https://api.example.com/v1/users?page=${page}&per_page=100`
    );
    const data = await response.json();

    users.push(...data.data);
    hasMore = data.pagination.page * data.pagination.per_page < data.pagination.total;
    page++;
  }

  return users;
}
```

### Implement Caching

<Accordions>
  <Accordion title="In-Memory Caching">
Cache frequently accessed data to reduce API calls:

```javascript title="cache.js"
const cache = new Map();

async function getCachedUser(userId, ttl = 300000) { // 5 minutes
  const cached = cache.get(userId);

  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data;
  }

  const user = await fetchUser(userId);
  cache.set(userId, { data: user, timestamp: Date.now() });

  return user;
}
```
  </Accordion>

  <Accordion title="Redis Caching">
Use Redis for distributed caching:

```javascript title="redis-cache.js"
const redis = require('redis');
const client = redis.createClient();

async function getCachedData(key, fetchFn, ttl = 300) {
  const cached = await client.get(key);

  if (cached) {
    return JSON.parse(cached);
  }

  const data = await fetchFn();
  await client.setEx(key, ttl, JSON.stringify(data));

  return data;
}
```
  </Accordion>
</Accordions>

### Parallel Requests

```javascript title="parallel-requests.js"
// Bad: Sequential requests
async function fetchDataSequential(userIds) {
  const users = [];
  for (const id of userIds) {
    const user = await fetchUser(id);
    users.push(user);
  }
  return users;
}

// Good: Parallel requests
async function fetchDataParallel(userIds) {
  const promises = userIds.map(id => fetchUser(id));
  return await Promise.all(promises);
}
```

## Security

<Callout type="warn">
**Security is non-negotiable.** Follow these practices to keep your integration secure.
</Callout>

<Accordions>
  <Accordion title="Store Credentials Securely">
- Use environment variables
- Never commit secrets to git
- Use secrets managers (AWS Secrets Manager, HashiCorp Vault)
- Rotate credentials regularly

```javascript title="secure-config.js"
// Good
const apiKey = process.env.API_KEY;

// Bad
const apiKey = "sk_live_123"; // Never hardcode!
```
  </Accordion>

  <Accordion title="Validate Webhook Signatures">
Verify webhook authenticity using signatures:

```javascript title="verify-webhook.js"
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const hmac = crypto.createHmac('sha256', secret);
  const digest = hmac.update(payload).digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(digest)
  );
}
```
  </Accordion>

  <Accordion title="Use HTTPS Only">
Always use HTTPS for API requests. Never send credentials over HTTP.

```javascript title="secure-request.js"
// Good
const url = 'https://api.example.com/v1/users';

// Bad
const url = 'http://api.example.com/v1/users'; // Insecure!
```
  </Accordion>

  <Accordion title="Implement CORS Properly">
For browser-based applications, configure CORS correctly:

```javascript title="cors-config.js"
const corsOptions = {
  origin: 'https://yourdomain.com',
  credentials: true,
  optionsSuccessStatus: 200
};
```
  </Accordion>
</Accordions>

## Rate Limiting

<Callout type="info">
**Respect Rate Limits**: Implement proper backoff strategies to avoid being rate limited.
</Callout>

### Exponential Backoff

```javascript title="exponential-backoff.js"
async function makeRequestWithBackoff(url, options, maxRetries = 5) {
  for (let i = 0; i < maxRetries; i++) {
    const response = await fetch(url, options);

    if (response.ok) {
      return await response.json();
    }

    if (response.status === 429) {
      const retryAfter = response.headers.get('Retry-After') || Math.pow(2, i);
      console.log(`Rate limited. Retrying after ${retryAfter}s`);
      await sleep(retryAfter * 1000);
      continue;
    }

    throw new Error(`Request failed: ${response.status}`);
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Monitor Rate Limit Headers

```javascript title="rate-limit-monitor.js"
async function makeRequestWithMonitoring(url, options) {
  const response = await fetch(url, options);

  const limit = response.headers.get('X-RateLimit-Limit');
  const remaining = response.headers.get('X-RateLimit-Remaining');
  const reset = response.headers.get('X-RateLimit-Reset');

  console.log(`Rate limit: ${remaining}/${limit} (resets at ${new Date(reset * 1000)})`);

  // Alert when approaching limit
  if (remaining < limit * 0.1) {
    console.warn('Approaching rate limit!');
  }

  return await response.json();
}
```

## Logging and Monitoring

<Callout type="success">
**Pro Tip**: Implement comprehensive logging to debug issues quickly in production.
</Callout>

```javascript title="logging.js"
const logger = {
  info: (message, meta) => {
    console.log(JSON.stringify({
      level: 'info',
      message,
      timestamp: new Date().toISOString(),
      ...meta
    }));
  },

  error: (message, error, meta) => {
    console.error(JSON.stringify({
      level: 'error',
      message,
      error: {
        message: error.message,
        stack: error.stack
      },
      timestamp: new Date().toISOString(),
      ...meta
    }));
  }
};

// Usage
try {
  const data = await makeRequest();
  logger.info('Request successful', { endpoint: '/users', count: data.length });
} catch (error) {
  logger.error('Request failed', error, { endpoint: '/users' });
}
```

## Testing

<Accordions>
  <Accordion title="Use Sandbox Environment">
Test in sandbox before deploying to production:

```javascript title="test-config.js"
const config = {
  development: {
    apiUrl: 'https://sandbox-api.example.com/v1',
    apiKey: process.env.SANDBOX_API_KEY
  },
  production: {
    apiUrl: 'https://api.example.com/v1',
    apiKey: process.env.PRODUCTION_API_KEY
  }
};

const env = process.env.NODE_ENV || 'development';
const apiConfig = config[env];
```
  </Accordion>

  <Accordion title="Write Integration Tests">
Test your API integration thoroughly:

```javascript title="api.test.js"
describe('API Integration', () => {
  it('should fetch users successfully', async () => {
    const users = await fetchUsers();
    expect(users).toBeInstanceOf(Array);
    expect(users.length).toBeGreaterThan(0);
  });

  it('should handle rate limiting', async () => {
    // Simulate rate limit
    const responses = await Promise.all(
      Array(200).fill().map(() => fetchUsers())
    );

    expect(responses).toBeDefined();
  });
});
```
  </Accordion>
</Accordions>
