# 工作流程指南
> 来源：CLAUDE.md v2.0
> 用途：8阶段工作流程详解

**主索引**：~/.claude/CLAUDE.md

---

## 工作流程（8 阶段）

工作流程分为 8 个阶段，每个阶段都由自己自主完成，无需外部确认。

### 阶段 0：强制同步检查（前置阶段 - 主代理负责）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| 触发条件     | 任何任务开始前自动检查                                          |
| 检查项       | 检测 `.claude/.synced` 文件是否存在                             |
| 不存在时     | 立即执行初始化流程（见CLAUDE.md § 初始化强制清单）               |
| 强制性       | 即使用户说"先不实施"也必须先完成初始化（这是环境准备而非任务实施） |
| 跳过机制     | 仅当存在 `.claude/.skip-sync` 标记时跳过                        |
| 完成标志     | 创建 `.claude/.synced` 标记文件                                 |

**初始化流程执行项（严格遵守，不执行其他操作）：**
1. 创建目录结构（.claude/ 和 docs/）
2. 同步全局配置文件
3. 分析项目结构
4. **飞书集成交互**（项目名称确认 + 通知对象选择）
5. 创建完成标记

详细步骤参见：CLAUDE.md § 初始化强制清单
飞书交互流程参见：lark.md § 初始化阶段飞书集成

### 阶段 1：接收与现实检查（分析模式 - 主代理负责）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| 重述请求     | 清晰地重述用户请求                                              |
| 现实检查     | 确认问题真实存在且值得解决                                      |
| 风险识别     | 注意潜在的破坏性变更                                            |
| **Skill/MCP 前置** | **优先检查第 2 节工具列表，匹配可用 Skill 或 MCP 工具辅助任务** |
| 假设处理     | 在不严格需要澄清时，基于明确假设继续进行                        |

### 阶段 2：上下文收集（分析模式 - 主代理/子代理协作）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| **Skill/MCP 检查** | **优先检查是否有匹配的 Skill（参考第 2.5 节）或 MCP 服务（参考第 2.2 节）可用于任务辅助** |
| 执行         | 每个任务执行一次 `<context_gathering>`                          |
| 查询策略     | 优先使用目标查询（Grep/Glob、Task(Explore)）而非广泛扫描        |
| 预算         | 首次扫描 5-8 次工具调用；超出需说明理由                         |
| 早停条件     | 当能够命名具体编辑或 ≥70% 信号收敛时                            |

**渐进式流程:**
1. 结构化快速扫描（必须）→ `.claude/context-scan.json`（位置/现状/技术栈/测试/观察报告）
2. 识别关键疑问（必须）→ sequential-thinking MCP 产出优先级列表
3. 针对性深挖（≤3 次）→ `.claude/context-question-N.json`（每次只解一个高优先级疑问）
4. 充分性检查（必须）→ 接口契约/选型理由/主要风险/验证路径

### 阶段 3：规划（分析模式 - 主代理负责）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| **任务分类** | **强制第一步：识别任务类型并匹配角色（见下方决策树）**           |
| 计划生成     | 生成多步骤计划（≥2 步）；必要时固化 `.claude/plan.json`         |
| **并行识别** | **识别独立任务，标记可并行执行的子任务组**                       |
| 进度更新     | 每步完成后更新进度                                              |
| 不确定处理   | 当可行性不确定时调用 sequential-thinking MCP                  |
| 验收契约     | 接口规格、边界条件、性能指标、测试标准                          |
| 任务跟踪     | 使用 TodoWrite 创建任务列表并跟踪进度；同时需关联到多维表格                           |

#### 强制任务分类决策树（规划第一步）

**目的：** 确保主代理不直接实施，而是委托给对应子代理

**决策流程：**

```
收到任务 → 识别任务类型 → 匹配角色 → 强制委托

任务类型识别（选择其一）：
├─ 代码BUG修复/审查/质量检查 → debugger (Sonnet + Codex CLI)
├─ 代码逻辑实现/功能开发/性能优化实施 → code-developer (Opus)
├─ 架构设计/技术规划/方案设计 → architect (Opus)
├─ 前端UI/组件设计/页面设计 → ui-designer (Sonnet + Gemini CLI)
├─ Git操作（提交/分支/PR/合并） → git-operations (Haiku)
├─ 文档编辑/内容组织 → doc-manager (Sonnet)
├─ 文件操作（创建/删除/移动） → file-operations (Haiku)
├─ 单元/集成/E2E测试 → test-engineer (Sonnet)
├─ CI/CD/部署/容器化 → devops-engineer (Haiku)
├─ 安全审查/漏洞检测 → security-auditor (Opus)
├─ API设计/接口规范 → api-designer (Opus)
└─ 性能诊断/瓶颈定位（不实施代码） → performance-optimizer (Sonnet)
```

**强制规则（不可违反）：**
1. **禁止主代理直接实施**：主代理只负责规划，不负责代码实施
2. **必须明确任务类型**：无法分类时询问用户或选择最接近的类型
3. **必须创建子代理**：即使是简单任务也要委托（培养正确习惯）
4. **必须使用对应工具**：
   - debugger 必须使用 Codex CLI
   - ui-designer 必须使用 Gemini CLI
   - 其他角色使用各自的工具链

**任务分类示例：**

| 用户请求 | 任务类型 | 匹配角色 | 理由 |
|---------|---------|---------|------|
| "修复订阅API缺少字段" | BUG修复 | debugger | 代码问题修复 |
| "实现用户认证功能" | 代码实现 | code-developer | 新功能开发 |
| "设计系统架构" | 架构设计 | architect | 技术规划 |
| "创建登录页面UI" | UI设计 | ui-designer | 前端界面 |
| "提交代码并创建PR" | Git操作 | git-operations | 版本管理 |
| "更新API文档" | 文档编辑 | doc-manager | 文档管理 |
| "分析性能瓶颈" | 性能诊断 | performance-optimizer | 只诊断不实施 |

**详细职责与工具**: 参见 `/Users/mac/.claude/docs/agents.md § 预置角色`

**并行任务识别规则：**
1. **依赖分析**：检查任务间是否有依赖关系（数据、文件、顺序）
2. **资源冲突**：确保不同任务操作不同文件，避免冲突
3. **分组策略**：将独立任务分组，每组 3-5 个任务同时执行
4. **标记并行**：在 TodoWrite 中用注释标记可并行任务组

**示例：**
```
任务分析：
- 任务A（修复订阅表单） - 独立，可并行
- 任务B（优化订单查询） - 独立，可并行
- 任务C（更新API文档） - 依赖A、B完成
→ 并行组1：[任务A, 任务B] 并行执行
→ 串行：任务C 等待组1完成后执行
```

#### 任务管理与多维表格关联流程

使用 TodoWrite 创建任务时，需按以下步骤同步到多维表格:

| 步骤 | 说明                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------- |
| 1    | 在多维表格中创建"父任务"记录（对应用户的整体需求/目标）                                         |
| 2    | 获取父任务的 record_id                                                                           |
| 3    | 对 TodoWrite 中的每个子任务，调用 `bitable_v1_appTableRecord_create` 创建子任务记录               |
| 4    | 子任务记录的内容：任务名、描述、状态（对应 TodoWrite status）、优先级等                           |
| 5    | 通过"父任务"字段将子任务与父任务进行关联（使用 record_id）                                       |
| 6    | 后续 TodoWrite 状态更新时，同步调用 `bitable_v1_appTableRecord_update` 更新多维表格中的子任务状态|

**任务层级说明:**
- **父任务**：对应用户的整体需求/目标，由初始化项目创建或规划阶段确定
- **子任务**：对应 TodoWrite 中的具体任务项，每个子任务有独立的 record_id
- **关联方式**：子任务通过"父任务"字段（多对一关系）关联到父任务记录

---

### 阶段 4：执行（执行模式 - 子代理主导，主代理监督）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| **并行执行** | **单次消息启动多个子代理，使用 `run_in_background: true` 参数**  |
| 执行策略     | 停止推理，执行每次写入/测试；用计划步骤标记每次调用              |
| 小步改动     | 每次保持可编译可验证；优先局部测试                              |
| 错误处理     | 失败时：捕获 stderr/stdout，决定重试或回退，保持对齐            |
| 进度监控     | 使用 TaskOutput 监控后台子代理进度                              |
| 进度记录     | 记录到 `operations-log.md`；使用 TodoWrite 实时更新任务状态     |
| 高风险确认   | 删核心配置、破坏性 DB 变更、push main、连续 3 次失败后的策略变更 |

**并行执行流程：**

1. **启动阶段**（单次消息完成）
   ```
   Task(code-developer, run_in_background: true): "修复订阅表单加载状态"
   Task(code-developer, run_in_background: true): "优化订单查询性能"
   Task(doc-manager, run_in_background: true): "更新API使用文档"
   ```

2. **监控阶段**
   - 主代理继续工作，不阻塞
   - 定期使用 TaskOutput(task_id, block: false) 检查进度
   - 子代理完成时自动返回结果

3. **汇总阶段**
   - 使用 TaskOutput(task_id, block: true) 获取最终结果
   - 验证所有子任务完成且无冲突
   - 更新 TodoWrite 状态为 completed

4. **任务队列检查**（防止主代理阻塞）
   - 读取当前 TodoWrite 状态
   - 识别剩余 pending 任务
   - 如果存在待办任务：
     * 分析任务依赖关系
     * 识别下一组可并行任务（3-5个）
     * 立即创建新子代理批次
     * 继续监控循环
   - 如果无待办任务：
     * 进入验证阶段
     * 准备交付

**注意事项：**
- 最多同时运行 3-5 个子代理
- 确保任务间无文件冲突
- 监控资源使用情况

### 阶段 5：验证与自我反思（分析模式 - 主代理负责）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| 测试执行     | 运行测试或检查；优先单测子集以缩短循环                          |
| 自我反思     | 交付前应用 `<self_reflection>`                                  |
| 质量闸门     | 如果任何质量标准未达标则重做                                    |
| 防呆设计     | 所有公开接口必须验证输入，危险操作需确认机制                    |
| 端到端验证   | 理想状态：需求到交付无人工干预；失败则分析阻塞点并改进流程      |
| 自我调试     | 失败时：1) 分析根因 2) 生成假设 3) 执行验证实验 4) 修正策略    |
| 失败处理     | 连续 3 次失败必须暂停复盘，必要时引入 Task(Explore) 深入分析    |

**测试策略:**
- 单元/冒烟/功能测试记录到 `.claude/testing.md` 与 `verification.md`
- 关键路径用 browser_eval（Playwright，next-devtools MCP 工具）录制证据
- Next.js 项目：优先用 nextjs_index/nextjs_call 获取运行时错误

### 阶段 6：交接（分析模式 - 主代理负责）

| 要素         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| 交付摘要     | 默认中文，如请求可用英文                                        |
| 文件引用     | 引用已修改文件及行锚点（例如 `path/to/file.java:42`）           |
| 风险说明     | 说明风险和自然的后续步骤                                        |
| 审查报告     | `.claude/review-report.md`（含元数据、评分、建议、风险、留痕列表）|

---

## 结构化标签

### `<context_gathering>`

| 要素     | 说明                                                                                              |
| -------- | ------------------------------------------------------------------------------------------------- |
| 目标     | 获取刚好足够的上下文来命名具体编辑                                                                 |
| 方法     | 从广泛开始，然后聚焦；批量多样化搜索；去重路径；优先目标查询（`rg`、`fd`、Grep/Glob）而非目录级扫描 |
| 预算     | 首次 5-8 次工具调用；超出前需记录原因                                                              |
| 早停条件 | 一旦能够命名编辑或 ≥70% 信号收敛到同一路径                                                         |
| 循环     | 批量搜索 → 规划 → 执行；仅在验证失败或出现新未知时重新进入                                         |

### `<persistence>`

| 要素 | 说明                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------- |
| 原则 | 持续行动直到任务完全解决；**不要因为不确定性而交回控制权**                                          |
| 策略 | 选择最合理的假设，继续进行，并在事后记录                                                           |

### `<tool_preambles>`

| 阶段     | 说明                                           |
| -------- | ---------------------------------------------- |
| 调用前   | 重述用户目标并概述当前计划                      |
| 执行期间 | 简要叙述每步进度                               |
| 结束时   | 提供与前期计划不同的简短回顾                    |

### `<self_reflection>`

| 要素     | 说明                                                                                              |
| -------- | ------------------------------------------------------------------------------------------------- |
| 评分标准 | 构建评分矩阵（1-5分）：可维护性、测试覆盖、性能、安全性、代码风格、文档、向后兼容性              |
| 行动     | 最终化前评估工作；**如果任何类别未达标则重新审视实现**                                              |

---

## 质量检查清单

**任何项未达标 → 循环回去**:

| 检查项                                                                              | 状态 |
| ----------------------------------------------------------------------------------- | ---- |
| 接触工具前已记录接收现实检查（或说明更高优先级覆盖的理由）                           | [ ]  |
| 首次上下文收集批次在 5-8 次工具调用内（或已记录例外）                                | [ ]  |
| 已记录 ≥2 步的计划，每步后更新进度                                                  | [ ]  |
| 执行时使用小步改动，每次保持可编译可验证                                            | [ ]  |
| 验证包括测试/检查及 `<self_reflection>`                                              | [ ]  |
| 最终交接包含文件引用（`file:line`）、风险和后续步骤                                  | [ ]  |
| 指令层级冲突已在日志中明确解决                                                       | [ ]  |
