# 代码编辑规范
> 来源：CLAUDE.md v2.0
> 用途：代码编写原则与技术栈规范

**主索引**：~/.claude/CLAUDE.md

---

## 6. 代码编辑规则

### 6.1 核心原则

| instruction                                                         | notes            |
| ------------------------------------------------------------------- | ---------------- |
| **简洁性**：倾向简单、模块化的解决方案；保持缩进 ≤3 层，函数单一职责 |                  |
| **KISS/YAGNI**：解决实际问题，而非想象的未来需求                     |                  |
| **向后兼容性**：未经明确批准，不得破坏现有 API 或用户空间契约        |                  |
| **复用模式**：使用现有项目模式；可读命名优于聪明技巧                 |                  |
| **减少假设**：通用抽象优于业务特定；所有接口必须验证输入合法性；避免隐式约定；优先标准化技术栈 |                  |
| 官方生态/SDK 优先；禁止无必要自研；已有自研评估替换或删除             |                  |
| 先修缺陷再扩展功能                                                   |                  |
| 小步修改；每次变更保持可编译可验证                                   |                  |
| 中文注释说明意图/约束/用法                                           |                  |
| 遵守 SOLID 与分层边界                                                |                  |
| 一致的语言/项目风格                                                  |                  |
| 禁止占位/MVP；提交完整实现                                           |                  |
| 破坏性变更需迁移与回滚方案                                           |                  |
| 清理过时与冗余实现                                                   |                  |
| 强化安全：最小权限/输入校验/错误隔离/密钥保护/审计留痕               |                  |
| 编码前研读上下文与相似实现，确认依赖/契约/测试约定                   | 基于证据         |
| gh CLI：用于 PR/Issue/Review 等端到端工作流                           | 官方建议         |

### 6.2 Java/Spring Boot 特定规则

| 规则                 | 说明                                                                                              |
| -------------------- | ------------------------------------------------------------------------------------------------- |
| Lombok 使用          | 使用 `@RequiredArgsConstructor` 进行构造器注入，`@Slf4j` 用于日志，`@Data` 用于简单 DTO          |
| 禁止全限定名         | 始终使用 `import` 语句；不要在代码中写 `java.util.List`                                           |
| 构造器注入           | 优先构造器注入而非字段注入（`@Autowired`）                                                        |
| 日志                 | 使用 SLF4J 占位符 `{}` 而非字符串拼接：`log.info("Processing: {}", item)`                         |
| 异常处理             | 使用 `@ControllerAdvice` 进行全局异常处理；在 Service 层抛出带错误码的 `BusinessException`        |
| 参数校验             | 在 Controller 中使用 `@Validated` 配合 JSR-303 注解                                                |

---

## 9. 沟通风格

### 9.1 语言规则

| 规则   | 说明                                                           |
| ------ | -------------------------------------------------------------- |
| 默认   | 用中文思考，用中文回答（自然流畅）                              |
| 可选   | 用户可请求"用英文思考"模式以应对复杂技术问题                    |
| 代码   | 变量名、函数名使用英文；**代码注释必须使用中文**                |

### 9.2 原则

| 原则       | 说明                                                           |
| ---------- | -------------------------------------------------------------- |
| 技术聚焦   | 发现优先于摘要；批评代码而非人                                  |
| 简洁性     | 保持输出简洁可操作                                              |
| 后续步骤   | 仅在自然跟随工作时提供                                          |
| 诚实       | 清楚说明假设、局限性和风险                                      |

---

## 9.3 输出规范

| 规则             | 说明                                                           |
| ---------------- | -------------------------------------------------------------- |
| 禁止表情符号     | 所有输出内容禁止存在任何表情符号（包括回复、代码、文档等）     |
| 代码输出限制     | 禁止输出超过 10 行的代码内容（过长代码使用 Edit/Write 工具）   |
| 文档存储位置     | 生成的**项目文档**存储在 `./docs/` 目录下（业务文档）；配置文档存储在 `./.claude/docs/` 下 |
| 文档代码限制     | 文档内禁止出现超过 20 行的代码内容                              |
| 下一步指引       | 每个操作输出必须包含：1) 操作结果 2) 相关ID/路径 3) 建议的下一步命令或操作 |

---

## 10. 开发哲学

| instruction                                      | notes        |
| ------------------------------------------------ | ------------ |
| 渐进式迭代，保持每次改动可编译、可验证           | 小步快跑     |
| 实现前研读既有代码或文档，吸收经验               | 学习优先     |
| 务实优先，满足真实需求                           | 实用主义     |
| 选择表达清晰的实现，拒绝炫技写法                 | 可读性优先   |
| 偏向简单方案，避免过度架构或早期优化             | 简单优于复杂 |
| 遵循既有代码风格（导入顺序、命名、格式化）       | 保持一致性   |

**简单性定义**：单一职责；三次重复后再抽象；避免"聪明技巧"；若需额外解释则继续简化。

**项目集成原则**：寻找≥3 个相似特性参考；沿用项目模式与约定；优先既有库/工具/夹具；遵循项目构建/测试/格式化设置。

---

## 11. 行为准则

| instruction                                                | notes        |
| ---------------------------------------------------------- | ------------ |
| 自主规划和决策，仅在真正需要用户输入时才询问               | 最大化自主性 |
| 基于观察和分析做出最终判断和决策                           | 证据驱动     |
| 充分分析和思考后再执行，避免盲目决策                       | 深思熟虑     |
| 禁止无依据假设或猜测，结论需援引代码或文档证据             | 证据驱动     |
| 如实报告执行结果，包括失败和问题，记录到 operations-log.md | 透明记录     |
| 复杂任务前完成详尽规划并记录                               | 规划先行     |
| 使用 TodoWrite 维护任务列表并及时更新                      | 进度跟踪     |
| 小步交付，确保每次提交可用                                 | 质量保证     |
| 学习既有实现优缺点并复用或改进                             | 持续改进     |
| 连续三次失败后必须暂停操作，重新评估策略                   | 策略调整     |

**极少数例外需确认**：删核心配置；破坏性 DB 变更；push main；三次失败后的策略调整；用户要求。

**默认自动执行**：本地读写/重构/文档/测试/依赖安装/本地 Git/构建/工具调用/按计划步骤/错误修复（≤3 次）。

---

## 前端性能优化

开发前端应用时，必须遵循以下性能优化原则：

### 核心Web指标优化

**1. 加快首屏渲染速度**
- Hero组件优先不使用motion动画
- 避免使用LazyImage懒加载首屏图片
- 第一时间渲染出内容，减少LCP（Largest Contentful Paint）延时
- 优先加载关键CSS和JavaScript

**2. 减少资源体积**
- 图片统一放在项目的 `/imgs` 目录下
- 使用tinypng等工具压缩图片，减少文件体积
- 优先使用WebP格式，降级到JPG/PNG
- 避免加载过大的第三方库

### 用户体验优化

**3. 增强网页无障碍性（Accessibility）**
- 给只有图标没有文字的 `<a>` / `<button>` 标签加上 `aria-label` 属性
- 确保键盘可访问性（tabindex、focus状态）
- 提供语义化的HTML结构
- 确保足够的颜色对比度

**4. 优化字体加载**
- 引入自定义字体时添加配置：
  ```typescript
  {
    display: 'swap',  // 字体加载期间显示系统字体
    preload: true     // 预加载字体文件
  }
  ```
- 使用font-display: swap消除FOIT（Flash of Invisible Text）
- 仅加载必要的字体权重和字符集

### 缓存策略

**5. 静态资源缓存**
在 `public/_headers` 和 `next.config.mjs` 配置静态资源缓存：
```
/imgs/*
  Cache-Control: public,max-age=31536000,immutable
```
- 让CDN明确缓存时长，实现零延迟加载
- 使用内容哈希确保缓存更新

**6. 静态页面缓存（Next.js ISR）**
在页面文件头部配置增量静态生成：
```typescript
export const revalidate = 3600; // 1小时重新生成
```
- 适用于更新不频繁的页面
- 减少服务器计算压力

### 服务端优化

**7. 优化服务端渲染（SSR）**
- 多个独立数据操作使用并行处理：
  ```typescript
  const [data1, data2, data3] = await Promise.all([
    fetchData1(),
    fetchData2(),
    fetchData3()
  ]);
  ```
- 降低TTFB（Time to First Byte）
- 避免阻塞渲染的串行请求

**8. 数据缓存配置**
使用Next.js缓存API优化数据读取：
```typescript
import { unstable_cache } from 'next/cache';
import { revalidateTag } from 'next/cache';

const getCachedConfigs = unstable_cache(
  async () => getConfigs(),
  ['configs'],
  { revalidate: 3600 }
);
```
- 频繁读取的数据缓存到内存或KV存储
- 使用标签实现精准缓存失效

### 性能检查清单

代码变更后，必须检查以下指标：
- [ ] LCP < 2.5s（最大内容绘制）
- [ ] FID < 100ms（首次输入延迟）
- [ ] CLS < 0.1（累积布局偏移）
- [ ] Lighthouse Performance Score > 90
- [ ] 图片已压缩且使用WebP格式
- [ ] 静态资源配置了长期缓存
- [ ] 无障碍性评分 > 90
